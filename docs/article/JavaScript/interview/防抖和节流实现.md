---
title: 防抖和节流的实现
date: 2019-08-01
---

防抖和节流其实它们主要都是为了减少函数的触发频率,提高性能

## 防抖 ##
防抖的主要功能在于,当您触发事件的时候,它会在某一个时间段内只会触发一次,它会从您调用该函数时开始计时,如果您不断地调用,可是时间还没达到,那么就不会执行

例如,您设定的时间是2秒执行一次,那么当您触发该函数的时候,它会2秒后才会执行,如果您在这个时间段内不断地触发该函数,那么就不会执行了,只有您停止触发了,到达时间了,函数才会正式给调用

**相应代码**
```js
function debounce(fn,delay = 200){
      // 如果没有定时器,那么就是null
      let timer = null;
      return function(){
        // 如果有定时器了, 那么就清理上一个定时器,所以如果您不断地执行函数,就会重新计算,函数就没法执行了
        if (timer) clearTimeout(timer);
        // 开启定时器,限定某个函数只能在某个时间段能执行一次
        timer = setTimeout(() => {
          // 调用我主要的业务逻辑函数,并且将我的this指向触该事件的元素,并且
          fn.apply(this,arguments);
          // 函数执行完毕,将定时器标识设置为null,防止内存泄露
          timer = null;
        }, delay);
      }
    }

    window.onresize = debounce(function (ev) {
      console.log(ev, this)
      console.log('窗口大小发生变化了') // 通过优化,在指定的时间内不断触发不会执行,确保某个时间段内只能执行一次
    }, 2000)

    // window.onresize = function () {
    //   console.log(1) // 如果不通过防抖来优化,那么每次只要一改变就会触发函数,影响性能
    // }
```

主要应用于: input验证、resize等

## 节流 ##

节流的主要作用在于,限制您的回调函数在某个时间段内只能执行一次,但是它不会像防抖那样,限制您在某个时间段内,如果频发执行就不会触发函数

## 相应代码 ##
```js
function throttle(fn, delay = 100){
      // 首先设定一个变量，在没有执行定时器时为null
      let timer = null;
      // 该函数执行会返回一个函数, 就是我的事件的回调函数
      return function () {
        // 判断如果我当前存在定时器,那么就直接结束该函数,这里就是为了防止多次触发
        if (timer) return;
        // 设置定时器标识,判断是否有开启定时器
        timer = setTimeout(() => {
          // 调用我主要的业务逻辑函数,并且将我的this指向触该事件的元素,并且传入arguments,让我函数内部可以获取到event对象
          fn.apply(this,arguments);
          timer = null;
        }, delay);
      }
    }

    document.onscroll = throttle(function(ev){
      console.log(ev, this)
      console.log('我是遥近啦,您好呀!') // 通过优化,就能使回调函数在某个时间段内只执行一次,但是不会像防抖一样,限制多次触发不执行
    }, 2000)
```

主要应用于: scroll


## 总结 ##

如果您想对某个事件,在某个时间段内只能执行一次,但是您又不想限制用户如果在这个时间段内多次执行时候,函数会发生不执行的情况,那么您就使用<span style='color: red'> 节流事件 </span>,

比如滚轮事件,懒加载时要监听计算滚动条的位置,但不必每次滑动都触发

如果您想对某个事件,它在某个时间段不断触发,您不想它执行,而是想过了某个时间段后才执行,那么您就可以使用<span style='color: red'> 防抖事件 </span>

比如,用户在某个表单中输入完数据后,您不必用户每次输入都抓取它的数据,而是等他输入完了,过了一段时间在获取

